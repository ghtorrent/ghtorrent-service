#!/usr/bin/env ruby

require 'queue_stuff'
require 'email_stuff'
require 'sinatra'
require 'digest/sha1'

require 'haml'
set :haml, {:ugly => true}

require 'sinatra/sequel'
set :database, 'sqlite://ght-service.db'

include QueueStuff
include EmailStuff

# Database automated construction
migration 'initial schema' do
  database.create_table :users do
    primary_key :id
    String      :name, :null => false
    String      :email, :null => false, :unique => true
    DateTime    :created_at, :null => false, :default=>Sequel::CURRENT_TIMESTAMP
  end

  database.create_table :repos do
    primary_key :id
    String      :name, :null => false, :unique => true
    DateTime    :created_at, :null => false, :default=>Sequel::CURRENT_TIMESTAMP
  end 

  database.create_table :requests do
    primary_key  :id
    foreign_key  :user_id, :users, :null => false
    String       :hash, :size => 40, :unique => true
    String       :last_msg
    DateTime    :created_at, :null => false, :default=>Sequel::CURRENT_TIMESTAMP
    DateTime    :updated_at, :null => false, :default=>Sequel::CURRENT_TIMESTAMP
  end

  database.create_table :request_contents do
    primary_key :id
    foreign_key :request_id, :requests, :null => false
    foreign_key :repo_id, :repos, :null => false
    TrueClass   :done, :null => false, :default => false
    DateTime    :updated_at, :null => false, :default=>Sequel::CURRENT_TIMESTAMP
  end

  database.create_table :request_contents_status do
    primary_key :id
    foreign_key :request_content_id, :request_contents, :null => false
    String      :text
    DateTime    :created_at, :null => false, :default=>Sequel::CURRENT_TIMESTAMP
  end
end

# What to do if a URL is not found
not_found do
  status 404
  haml :'404'
end

get '/' do
  haml :index
end

# Basic service logic: Handle a request and render the appropriate templates
# to answer it.
post '/requests' do
  errors = []
  name  = request[:name]
  email = request[:email]
  projects = request[:repos]

  # Parameter check
  if name.nil? or name.strip.empty?
    return haml :error, :locals => {:error => 'User name empty'}
  end

  if email.nil? or email.strip.empty?
    return haml :error, :locals => {:error => 'Email empty'}
  end

  if email.match(/^.+@.+$/).nil?
    return haml :error, :locals => {:error => "The provided email <#{email}> is not a valid email"}
  end

  if projects.nil? or projects.strip.empty?
    haml :error, :locals => {:error => 'No projects specified'}
  end

  #database.loggers << logger

  # Check and register user if necessary
  user = database[:users].where(:email => email).first
  if user.nil?
    database[:users].insert(
        :name => name,
        :email => email
    )
    logger.info "Added user #{name} <#{email}>"
  end
  user = database[:users].where(:email => email).first

  # Check whether the user has unfinished requests
  unfinished_request =
      database.from(:request_contents, :requests)\
              .where(:request_contents__request_id => :requests__id)\
              .where(:request_contents__done => false)\
              .select(:requests__hash).first

  # If there is an unfinished request return an error
  unless unfinished_request.nil?
    logger.warn("User #{name} has a pending request")
    return haml :error, :locals => {
        :error => "Your request with id <em>#{unfinished_request[:hash]}</em>
                   has not finished yet. You can only have one request at a time
                   running. You can see the status of your unfinished request
                   <a href='/requests/#{unfinished_request[:hash]}'>here</a>."}
  end

  # Done with checks, on to action. Run it in a transaction to fail
  # atomically in case of error.
  begin
    database.transaction(:rollback => :reraise, :isolation => :committed) do
      # Add the request
      req_hash = Digest::SHA1.hexdigest(("#{user}#{projects}").split(//).shuffle.join)
      database[:requests].insert(
        :user_id  => user[:id],
        :hash => req_hash
      )

      req = database[:requests].first(:hash => req_hash)

      # Add the repos to retrieve to the request
      jobs = projects.split(/\r?\n/).map do |x|
        x.strip!

        (owner, repository) = x.split(/\//)

        # Consistency checks for reqo and owner names. This is to prevent
        # SQL injections, hopefuly.
        if owner.nil? || !owner.match(/^[a-zA-Z\-_.]+$/)
          msg = "Ignoring project: #{x} Wrong user name."
          logger.warn(msg)
          errors << msg
          next
        end

        if repository.nil? || !repository.match(/^[a-zA-Z.\-_]+$/)
          msg = "Ignoring project: #{x} Wrong project name."
          logger.warn(msg)
          errors << msg
          next
        end

        # Make sure that the repo exists
        if database[:repos].first(:name => x).nil?
          database[:repos].insert(:name => x)
        end

        repo = database[:repos].first(:name => x)

        # Add the request for this repo
        database[:request_contents].insert(
          :repo_id => repo[:id],
          :request_id => req[:id]
        )

        [req[:id], owner, repository].flatten
      end.select{|x| !x.nil?}

      # All requests are in the database, add them to the queue as well.
      jobs.each do |x|
        logger.debug("Adding job: #{x[0]} -> #{x[1]}/#{x[2]}")
        #amqp_exchange.publish("#{x[0]} #{x[1]} #{x[2]}",
        #                      {:timestamp => Time.now.to_i,
        #                       :persistent => true,
        #                       :routing_key => JOB_QUEUE})
      end
      send_req_succeed(email, name, req[:hash], "/requests/#{req[:hash]}")
    end
  rescue Exception => e
    logger.error e.message
    logger.error e.backtrace.join("\n")

    send_email('G.Gousios@tudelft.nl',
               [e.message, e.backtrace.join("\n")].join("\n\n"))
    return haml :error, :locals => {
        :error => 'An error occured that prevented GHTorrent to fullfil your
                   request. Try again later.'}
  end

  return haml :result, :locals => {:errors => errors, :url => "/requests/#{req[:hash]}"}
end

# Request status display
get '/requests/:id' do |id|

  if id.nil? or id.strip.empty? or id.size < 40
    return haml :error, :locals => {:error => 'Incorrect request id'}
  end

  id = id[0..39]
  req = database[:requests].first(:hash => id)

  if req.nil?
    return haml :error, :locals => {:error => 'Non-existent request'}
  end

  database[:request_contents].where(:request_id => req[:id])\
                             .all\
                             .reduce('<ul>') do |acc, rc|
    repo = database[:repos].first(:id => rc[:repo_id])
    status_msgs = database[:request_contents_status].where(:request_content_id => rc[:id]).all

    acc << '<li>' << repo[:name] << '</li>'
    if status_msgs.size > 0
      acc << '<ul>'
      status_msgs.each do |msg|
        acc << '<li>[' << msg[:created_at] << ']' << msg[:text] << '</li>'
      end
      acc << '</ul>'
    end
    acc
  end << '</ul>'

end

__END__

@@index
!!! 5
%html
  %head
    %meta(charset="utf-8")
%body
  .content
  %form{ :action => "/requests", :method => "post"}
    %fieldset
      %label{:for => "name"} Name:
      %input{:type => "text", :name => "name", :required => true}
      %br/
      %label{:for => "mail"} Email:
      %input{:type => "text", :name => "email", :required => true}

      %br/
      %label{:for => "body"} Enter the names of the repositories you want to retrieve, one per line:
      %br/
      %textarea{:name => "repos", :cols => "40", :rows => "30"}
      %br/
      %input{:type => "submit", :value => "Send", :class => "button"}

@@result
!!! 5
%html
  %head
    %meta(charset="utf-8")
%body
  .content Thanks for using GHTorrent. We sent you an email with a unique URL. Use it to check the status of your request. We will also send you an email when your request is ready to download.

  .content You can view your request status here: url

  - if errors.size > 0
    .content Your request generated the following warnings:
    %ul
      - errors.each do |error|
        %li= error


@@status
!!! 5
%html
  %head
    %meta(charset="utf-8")
%body
  .content


@@error
!!! 5
%html
  %head
    %meta(charset="utf-8")
%body
  %h1 Error
  .content #{error}


@@ 404
  .error.title
    Nothing to see here...

